// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "AbstractTreeModel.h"
#include "AbstractTreeNode.h"

// This class is in the spirit of the python classes at
// http://www.hardcoded.net/articles/using_qtreeview_with_qabstractitemmodel.htm
//
// This is a very simple "read-only" model that does not support fine-grained updates.
// Instead, it is expected that every method of the derived model class works like this:
// void DerivedModel::addData( ... ) {
//   beginResetModel(); // Signal to views that the model data will be invalidated.
//   ... do stuff to the underlying data.
//   init(); // Re-generate all nodes.
//   endResetModel(); // Force all views to re-read everything from the model.
// }
//
// Some notes:
// * The (invisible) root of a tree model is an invalid QModelIndex.
// * Only the first column has children.
// * We are storing raw pointers to data as internalPointer.
//   This is okay, since users must never use invalid QModelIndexes anyway.
// * internalPointer() points to instances of AbstractTreeNode, not to the
//   actual implementation-specific data. Instead, the concrete class derived
//   from AbstractTreeNode needs to hold a reference to the actual data.
// * Derived classes have to call init() at some point during construction,
//   when they have initialised themselves enough for getRootNodes to be called.
//   init() can not be called from this class' constructor since at the time
//   the "this" pointer is of type AbstractTreeModel* and createRootNodes()
//   is pure virtual.

class AbstractTreeModel::Private
{
public:
    QList<NodePtr> rootNodes;
};

AbstractTreeModel::AbstractTreeModel(QObject *parent) :
    QAbstractItemModel(parent), d(new Private())
{
}

AbstractTreeModel::~AbstractTreeModel()
{
}

void AbstractTreeModel::init()
{
    d->rootNodes = createRootNodes();
}

QModelIndex AbstractTreeModel::index(int row, int column, const QModelIndex & parent) const
{
    if(!hasIndex(row, column, parent))
        return QModelIndex();

    if(!parent.isValid()) {
        // Return QModelIndex to a first level node.
        return createIndex(row, column, d->rootNodes[row].data());
    } else {
        AbstractTreeNode * parentNode = static_cast<AbstractTreeNode*>(parent.internalPointer());
        return createIndex(row, column, parentNode->childNodes()[row].data());
    }
}

QModelIndex AbstractTreeModel::parent(const QModelIndex & index) const
{
    if(!index.isValid())
        return QModelIndex();

    AbstractTreeNode * node = static_cast<AbstractTreeNode*>(index.internalPointer());
    AbstractTreeNode * parentNode = node->parentNode();
    if(parentNode == NULL) {
        // Parent of first level node is root.
        return QModelIndex();
    } else {
        // Only the first column (0) has children.
        return createIndex(parentNode->row(), 0, parentNode);
    }
}

int AbstractTreeModel::rowCount(const QModelIndex & parent) const
{
    if(!parent.isValid()) {
        return d->rootNodes.size();
    } else {
        // Only the first column (0) has children.
        if(parent.column() != 0)
            return 0;

        AbstractTreeNode * node = static_cast<AbstractTreeNode*>(parent.internalPointer());
        return node->childNodes().size();
    }
}
